浏览器插件如何通过文件绝对路径读取本地文件/文件夹，
我知道给权限，我自己用百分之百的权限都可以给无所谓，我就是想把一堆本地路径地址的数组，然后一个个自动上传，不用我手动选择简化操作。

使用Chrome的fileSystem API并持久化权限：如果你使用Chrome扩展，并且文件都在同一个目录下，你可以先让用户选择一次目录，然后扩展会获得该目录的权限，并且可以将该目录的权限持久化。之后，你可以通过文件路径直接读取该目录下的文件，而无需再次选择。但是，这要求文件都在同一个目录下，并且用户需要先授权一次。
使用File System Access API（Chrome 86+）：这个API允许网站在用户授权后访问文件系统。你可以让用户授权一个目录，然后就可
我对这里比较感兴趣，因为上传的文件都在同一个项目文件夹中，为了不全部上传，只上传其中的特定文件夹或文件
除了第一次授权需要用户（我自己）交互确定外，后续就可以通过代码自动上传【文件路径数组】里的文件？

最终的实现路径并非直接“读取绝对路径”，而是转变为一种更安全、更现代的模式：用户首先通过交互授权一个根目录（例如您的项目文件夹），扩展程序将获得该目录的持久访问权限。之后，扩展可以根据您提供的绝对路径列表，计算出这些文件相对于已授权根目录的路径，并以编程方式自动、静默地访问和上传这些文件。

// popup.js

// 简化的 IndexedDB 操作
const db = {
async get(key) { /* ... IndexedDB get logic ... */ },
async set(key, value) { /* ... IndexedDB set logic ... */ }
};

document.getElementById('select-dir').addEventListener('click', async () => {
try {
// 1. 用户交互，弹出目录选择器
const dirHandle = await window.showDirectoryPicker();

    // 2. 请求读写权限
    const permissionStatus = await dirHandle.requestPermission({ mode: 'readwrite' });
    if (permissionStatus !== 'granted') {
      throw new Error('未授予目录读写权限');
    }

    // 3. 将句柄存入 IndexedDB
    await db.set('projectRootHandle', dirHandle);
    document.getElementById('status').textContent = '状态：已授权，根目录已保存！';
    console.log('目录句柄已成功保存。');
} catch (error) {
console.error('授权失败:', error);
document.getElementById('status').textContent = `状态：授权失败 - ${error.message}`;
}
});
5.3 第三步：自动化上传逻辑 (background.js)
这是后台的核心逻辑，负责在特定时机（例如，点击扩展图标时，或接收到特定消息时）执行上传。

// background.js

// 假设这是您要上传的文件绝对路径列表
const absolutePathsToUpload = [
'D:\\MyProject\\src\\main.js',
'D:\\MyProject\\package.json',
'D:\\MyProject\\src\\components\\Button.vue'
];

// 上传单个文件的函数
async function uploadFile(fileObject) {
const formData = new FormData();
formData.append('file', fileObject, fileObject.name);

try {
const response = await fetch('https://your-upload-endpoint.com/upload', {
method: 'POST',
body: formData,
});
if (!response.ok) {
throw new Error(`服务器错误: ${response.statusText}`);
}
console.log(`文件 ${fileObject.name} 上传成功！`);
} catch (error) {
console.error(`文件 ${fileObject.name} 上传失败:`, error);
}
}

// 主执行函数
async function processUploads() {
// 1. 从 IndexedDB 读取根目录句柄
const rootHandle = await db.get('projectRootHandle');
if (!rootHandle) {
console.log('未找到根目录句柄，请先在弹出窗口中授权。');
return;
}

// 2. 验证并确保权限是 'granted'
const permission = await rootHandle.queryPermission({ mode: 'readwrite' });
if (permission !== 'granted') {
// 尝试重新请求，如果用户授予了持久权限，这里不会有弹窗
if (await rootHandle.requestPermission({ mode: 'readwrite' }) !== 'granted') {
console.error('无法获取目录权限，请重新授权。');
return;
}
}

// 假设我们需要获取根目录的路径以便进行路径计算
// 注意：FSA API本身不直接暴露句柄的完整路径，这是一个安全特性。
// 通常，您需要将根目录的名称或标识与绝对路径关联起来。
// 这里我们做一个简化假设：用户授权的目录就是列表中所有路径的公共前缀。
// 在实际应用中，您可能需要在授权时让用户确认或输入根目录的路径。
const rootPath = 'D:\\MyProject'; // 此处需要一个健壮的方式来确定根路径

for (const absPath of absolutePathsToUpload) {
if (!absPath.startsWith(rootPath)) {
console.warn(`路径 ${absPath} 不在已授权的目录 ${rootPath} 中，已跳过。`);
continue;
}

    // 3. 计算相对路径并获取文件句柄
    const relPath = absPath.substring(rootPath.length + 1).replace(/\\/g, '/');
    const pathSegments = relPath.split('/').filter(p => p);
    
    try {
      let currentHandle = rootHandle;
      for (let i = 0; i < pathSegments.length - 1; i++) {
        currentHandle = await currentHandle.getDirectoryHandle(pathSegments[i]);
      }
      const fileHandle = await currentHandle.getFileHandle(pathSegments[pathSegments.length - 1]);

      // 4. 获取文件对象并上传
      const file = await fileHandle.getFile();
      await uploadFile(file);
    } catch (error) {
      console.error(`处理文件 ${absPath} 时出错:`, error);
    }
}
}

// 可以在适当的时机调用 processUploads()
// 例如，当用户点击扩展的浏览器操作图标时
chrome.action.onClicked.addListener((tab) => {
processUploads();
});