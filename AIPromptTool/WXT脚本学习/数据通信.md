## 三种脚本类型数据间通信：
Background Script <–> Content Script <–> Page Script(Injected Script)
### 前情提示
>发送的消息内容，必须是可序列化的任意 JavaScript 值（对象、数组、字符串、数字、布尔等）。
>❌ 不能直接传函数、DOM 对象等不可序列化的类型。
>  传DOM 的序列化数据（如 outerHTML、属性对象） 在接收端重新构建 DOM对象。
> 可以双向通信，收到消息时可以回一个值，作为响应。异步回消息时需要特别处理
> 消息内容的字段完全可以自定义，如type，data，payload，error，id等，只要可以序列化（ JSON 结构传递的（底层是结构化克隆算法））
>Background ↔ Content 之间的消息走的是扩展内部的runtime 消息通道,网页的 JavaScript 无法访问 browser.runtime.onMessage 事件。不会被网页监听到 ✅
> Content ↔ Page 之间的消息,通过 window.postMessage 通信的，这是页面全局的事件,会被网页监听到 ⚠️
#### WXT版browser.runtime.sendMessage
>WXT 已经内置了 polyfill，所以在 WXT 项目里直接用 browser.runtime.sendMessage 就行，  
>它会自动适配 Chrome 和 Firefox。
### 原生 WebExtension
#### Content Script <-> Background Script
chrome/browser.runtime.sendMessage({})
chrome/browser.runtime.onMessage.addListener({})

#### Content Script <-> Page Script: 
```js
// content.js
window.addEventListener("message", e => {
  if (e.source === window && e.data.type === "FROM_PAGE") {
    console.log("content 收到页面消息:", e.data.payload);
  }
});
window.postMessage({ type: "FROM_CONTENT", payload: "content 消息" }, "*");

// page-injectScript.js
window.addEventListener("message", e => {
  if (e.source === window && e.data.type === "FROM_CONTENT") {
    console.log("页面收到 content 消息:", e.data.payload);
  }
});
window.postMessage({ type: "FROM_PAGE", payload: "页面消息" }, "*");
```


### 更详细的示例
#### Content Script -> Background Script (单向发送消息)
> sendMessage(message, options)的第一个参数是发送的消息内容message，必须是可序列化的，第二个参数可选默认空即可。
> onMessage(message, sender, sendResponse),  
> message: 发送的消息内容，必须是可序列化的。
> sender: 发送消息的来源，是一个对象，包含 sender.id、sender.url、sender.tab 等属性。  
> sendResponse(response)，发送消息的响应，用于双向通信。
```js
 // content向 background 发送消息
browser.runtime.sendMessage({type:"message1",data:"来自content的消息"})
 // background 监听来着content的消息
browser.runtime.onMessage.addListener(
    (message, sender, sendResponse) => {
        console.log('Received message:', message);
        if(message.type==="message1"){
            console.log("收到message1",message.data)
        }
    }
)
```
#### Content Script -> Background Script ->Content Script (双向发送消息)
>sendMessage().then().catch()  返回的是Promise  
> then(),用于获取回复，response是一个可序列化的对象，自定义字段。  
> catch(),用于捕获错误，err对象{name，message, stack}
```js
 browser.runtime.sendMessage(
    {
        type: "ADD_NUMBERS",
        payload: { a: 5, b: 3 }
    }
).then(response => {
    console.log('[Content] 收到 Background 回复:', response);
}).catch(err => {
    console.error('[Content] 发送消息失败:', err);
});
```
> sendResponse(response)，发送消息的响应，只response一个参数，且必须是可序列化的。  
> 异步回复 Manifest V3 不需要 return true
```js
browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('[Background] 收到消息:', message);

    if (message.type === "ADD_NUMBERS") {
      const { a, b } = message.payload;
      
      // 模拟异步处理（比如从数据库/API获取数据）
      setTimeout(() => {
        const result = a + b;
        sendResponse({
          ok: true,
          result: result,
          message: '计算完成'
        });
      }, 1000);

      // 异步回复必须 return true，// 异步回复 Manifest V3 不需要 return true
      // return true;
    }
  });
```
#### Background Script -> Content Script (单向发送消息)
> Background 是全局的，它可以和浏览器里所有的 Tab、所有的 Content Script 通信，需要指定发送的标签页ID
> browser.tabs.sendMessage(tab.id, message)
> browser.tabs.query() 用于获取标签页信息，active: true 表示当前激活的标签页，currentWindow: true 表示在当前窗口
```js
try {
    // 获取当前激活的标签页
    const [tab] = await browser.tabs.query({ active: true, currentWindow: true });
    if (!tab.id) return;
    // 向 Content Script 发送单向消息
    browser.tabs.sendMessage(tab.id, {
        type: 'NOTIFICATION',
        payload: `当前时间：${new Date().toLocaleTimeString()}`
    });
    console.log('[Background] 已向 Content 发送消息');
} catch (err) {
    console.error('[Background] 发送消息失败:', err);
}
```
```js
// content.js
browser.runtime.onMessage.addListener((message) => {
    console.log('[Content] 收到 Background 消息:', message);

    if (message.type === 'NOTIFICATION') {
        console.log('[Content] 通知内容:', message.payload);
        // 这里可以操作 DOM，比如显示通知
        alert(`收到后台通知：${message.payload}`);
    }
});
```
#### Background Script -> Content Script -> Background Script (双向发送消息)
//await 本质是 Promise 的语法糖
```js
try {
      // 1. 获取当前激活标签页
      const [tab] = await browser.tabs.query({ active: true, currentWindow: true });
      if (!tab.id) return;

      console.log('[Background] 向 Content 发送任务...');

      // 2. 用 await 等待 Content 回复（核心：await 本质是 Promise 的语法糖）
      const response = await browser.tabs.sendMessage(tab.id, {
        type: 'ADD_NUMBERS',
        payload: { a: Math.floor(Math.random() * 100), b: Math.floor(Math.random() * 100) }
      });

      // 3. 成功收到回复
      console.log('[Background] 收到 Content 回复:', response);
    } catch (err) {
      // 4. 捕获所有错误（获取 tab 失败、发送消息失败、Content 没回复等）
      console.error('[Background] 发送消息失败:', err);
    }
```
```js
browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'ADD_NUMBERS') {
    setTimeout(() => {
      const sum = message.payload.a + message.payload.b;
      sendResponse({ ok: true, result: sum });
    }, 1000);
    return true; // 异步回复建议 return true
  }
});
```
```js
// content.js
window.addEventListener("message", e => {
  if (e.source === window && e.data.type === "FROM_PAGE") {
    console.log("content 收到页面消息:", e.data.payload);
  }
});
window.postMessage({ type: "FROM_CONTENT", payload: "content 消息" }, "*");

// page-injectScript.js
window.addEventListener("message", e => {
  if (e.source === window && e.data.type === "FROM_CONTENT") {
    console.log("页面收到 content 消息:", e.data.payload);
  }
});
window.postMessage({ type: "FROM_PAGE", payload: "页面消息" }, "*");
```

#### Content Script <-> Page Script
> window.postMessage(),
> 参数：message序列化数据, 
> targetOrigin接收方的源（origin）,"协议+主机名+端口","*","window.location.origin"
> transfer，不重要。
```js
// 向 主世界Page 发送消息
window.postMessage(
    { type: "FROM_CONTENT", payload: "content 消息" },
    window.location.origin // 限制接收方
);
```
>message事件
> e.data，message数据，消息内容
> e.source, 发送方窗口对象
> e.origin, 发送方源（origin）
```js
// 接收 Content 发来的消息
window.addEventListener("message", e => {
    // 验证来源
    if (e.source === window && e.data?.type === "FROM_CONTENT") {
        console.log("页面收到 content 消息:", e.data.payload);
    }
});
```



WXT本身并未简化通信机制，推荐使用一些库来进行简化，不要重复造轮子，
```
库	特点	学习成本	推荐场景
webext-bridge	轻量、API 简洁、支持 Promise	低	中小型项目，简单消息传递
@webext-core/messaging	轻量、类型安全、支持中间件	中	需要类型安全的中小型项目
trpc-chrome	基于 tRPC，端到端类型安全	高	大型项目，复杂 API 调用
@webext-core/proxy-service	像调用本地函数一样调用 background 方法	中	需要跨上下文函数调用
```





